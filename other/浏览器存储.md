## Cookie：
Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。

Cookie 包含以下几方面的信息：
1. Cookie 的名字
2. Cookie 的值（真正的数据写在这里面）
3. 到期时间
4. 所属域名（默认是当前域名）
5. 生效的路径（默认是当前网址）
由于document.cookie返回的是分号分隔的所有 Cookie，所以必须手动还原，才能取出每一个 Cookie 的值。
```js
var cookies = document.cookie.split(';');
for (var i = 0; i < cookies.length; i++) {
  // cookies[i] name=value形式的单个Cookie
}
```
document.cookie属性是可写的，可以通过它为当前网站添加 Cookie。
document.cookie = 'fontSize=14';
Cookie 的值必须写成key=value的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值）
document.cookie一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。
分类：非持久Cookie和持久Cookie
cookies的属性：
(1)value属性
value属性是必需的，它是一个键值对，用于指定Cookie的值。

(2)expires属性
expires属性用于指定Cookie过期时间。它的格式采用Date.toUTCString()的格式。
如果不设置该属性，或者设为null，Cookie只在当前会话（session）有效，浏览器窗口一旦关闭，当前Session结束，该Cookie就会被删除。
浏览器根据本地时间，决定Cookie是否过期，由于本地时间是不精确的，所以没有办法保证Cookie一定会在服务器指定的时间过期。

(3)domain属性
domain属性指定Cookie所在的域名，比如example.com或.example.com（这种写法将对所有子域名生效）、subdomain.example.com。
如果未指定，默认为设定该Cookie的域名。所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是example.com，就不能将其设为google.com。只有访问的域名匹配domain属性，Cookie才会发送到服务器。

(4)path属性
path属性用来指定路径，必须是绝对路径（比如/、/mydir），如果未指定，默认为请求该Cookie的网页路径。
只有path属性匹配向服务器发送的路径，Cookie才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要path属性匹配发送路径的一部分，就可以发送。比如，path属性等于/blog，则发送路径是/blog或者/blogroll，Cookie都会发送。path属性生效的前提是domain属性匹配。

(5)secure
secure属性用来指定Cookie只能在加密协议HTTPS下发送到服务器。
该属性只是一个开关，不需要指定值。如果通信是HTTPS协议，该开关自动打开。

(6)max-age
max-age属性用来指定Cookie有效期，比如60 * 60 * 24 * 365
（即一年31536e3秒）

(7)HttpOnly
HttpOnly属性用于设置该Cookie不能被JavaScript读取.
（即document.cookie不会返回这个Cookie的值），只用于向服务器发送。

例子：
```js
function setCookie(cname,cvalue,exdays){
    var d = new Date();
    d.setTime(d.getTime()+(exdays*24*60*60*1000));
    var expires = "expires="+d.toGMTString();
    document.cookie = cname+"="+cvalue+"; "+expires;
}
function getCookie(cname){
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name)==0) { return c.substring(name.length,c.length); }
    }
    return "";
}
function checkCookie(){
    var user=getCookie("username");
    if (user!=""){
        alert("欢迎 " + user + " 再次访问");
    }
    else {
        user = prompt("请输入你的名字:","");
          if (user!="" && user!=null){
            setCookie("username",user,30);
        }
    }
}
```
使用web存储之前，应该先检查一下浏览器是否支持localStorage和sessionStorage(I7以下不支持)
判断方法
if(typeof(localStorage !=='undefined'){
};

或者if(window.localStorage){}

1. getItem(key):获取指定key所存储的value值
2. key(index)方法：返回列表中对应索引的key值
3. length属性：返回key/value队列的长度
4. removeItem(key)方法：从Storage中删除一个对应的键值对。
5. setItem(key,value)方法：将value存储到key指定的字段。

clear()方法：移除所有的内容
# Session：
特点：
1. 同源策略限制。若想在不同页面之间对同一个sessionStorage进行操作，这些页面必须在同一协议、同一主机名和同一端口下。(IE 8和9存储数据仅基于同一主机名，忽略协议（HTTP和HTTPS）和端口号的要求)
2. 单标签页限制。sessionStorage操作限制在单个标签页中，在此标签页进行同源页面访问都可以共享sessionStorage数据。
3. 只在本地存储。seesionStorage的数据不会跟随HTTP请求一起发送到服务器，只会在本地生效，并在关闭标签页后清除数据。(若使用Chrome的恢复标签页功能，seesionStorage的数据也会恢复)。
4. 存储方式。seesionStorage的存储方式采用key、value的方式。value的值必须为字符串类型(传入非字符串，也会在存储时转换为字符串。true值会转换为"true")。
5. 存储上限限制：不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。

方法，对localstorage适用：
1. 方法 string sessionStorage.key(int index) ：返回当前 sessionStorage 对象的第index序号的key名称。若没有返回null。
2. 方法 string sessionStorage.getItem(string key) ：返回键名(key)对应的值(value)。若没有返回null。
3. 方法 void sessionStorage.setItem(string key, string value) ：该方法接受一个键名(key)和值(value)作为参数，将键值对添加到存储中；如果键名存在，则更新其对应的值。
4. 方法 void sessionStorage.removeItem(string key) ：将指定的键名(key)从 sessionStorage 对象中移除。
5. 方法 void sessionStorage.clear() ：清除 sessionStorage 对象所有的项。