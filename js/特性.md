# 总结

## call和apply的区别
- 都是改变this的指向,都是fn原型的方法
- fn.call(obj,10,20,30):call一个一个传
- fn.apply(obj,[10,20,30]):传一个数组
- call性能比apply好一些；尤其是传递给函数参数超过3个；

## console

可以测试一段程序执行的时间
- console.time('A')
- console.timeEnd('A')

## 函数

[[toc]]

### 箭头函数
0. 语法简洁

`fn=()=>{}`

1. 没有this，thi从属于函数所处上下文中的this，任何方式都`无法改变this`的指向；
```js
fucntion fn(x){
    return function(y){
        return x+y;
    }
}
// 等同于
let fn=x=>y=>x+y;
```

::: danger 注意
回调函数的this指向window；
:::


1. 箭头函数没有arguments（类数组）只能给予...arg获取传递的参数集合（数组）
```js
fn=(..arg)=>{
    console.log(...arg)
}
```

3. 箭头函数不能被new执行。箭头函数没有this，没有protype属性；
```js
let fn=()=>{
    this.x=200
}
```

## Symbol
Symbol是ES6中新增的类型，它创建出来的值是唯一的；
```js
Symbol('123')==Symbol('123')//false
```
对象的属性名不能是对象，遇到对象属性名，会默认转为字符串；

## 判断url是否为正确
1. 协议: http、https、ftp
2. 域名: www.xxx.com、 xxx.cn、xxx.bbb.ccc.com.cn
3. 请求路径: /index.html /xxx/ 
```js
let str="https://www.yating.online/api?num=1&page=5"
let reg=/^(https|http|ftp):\/\/)?(([\w-]+\.\.)+[a-z0-9]+)((\/[^/]*)+)?(\?[^#]+)?(#.+)$/i;
```

## 公有私有方法
```js
function Foo(){
    Foo.a=function(){
        console.log(1)
    }
    this.a=function(){
        console.log(2)
    }
}
// 吧Foo当做类，在原型上设置实例公有属性方法
Foo.prototype.a=function(){
    console.log(4)
}
//把foo当做普通对象设置私有属性方法 
Foo.a=function(){
    console.log(3)
}

Foo.a();//3
new obj=new Foo();//会执行Foo();替换之前的
obj.a();
Foo.a();

// 结果为：3，2，1
```