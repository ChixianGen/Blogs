# 写编程题

## 写交集
```js
let nums1=[12,23,34,45,34,25,46,35]
let nums2=[10，5，4，6，56，23]
let arr[];

// 1、 forEach、includes
nums1.forEach(item=>nums2.includes(item)?arr.push(item):null);

// 2、for
for(let i=0;i<nums1.length;i++){
    for item1=nums1[i];
    for(let j=0;j<nums2.length;j++){
        let item2=nums2[j];
        if(item1==item2){
            arr.push(item1);
            break;
        }
    }
}

// 3、forEach
nums1.forEach((item,index)=>{
    let n=nums2.indexOf(item);// n 当前想在第二个数组中找到相同项的索引
    if(n>=0){
        arr.push(item);
        nums1.splice(index,1);
        nums2.splice(n,1)
    }
})
```

## 函数柯理化
> 预先处理的思想（利用闭包的机制）

### 最简单的柯理化函数
```js
// 最简单的柯理化函数,预先在闭包中把x值存储起来
function fn(x){
    return function(y){
        return x+y;
    }
}
fn(100)(200)
```

### 例子
```js
doucument.body.onclick=fn;//this:body arg：[事件对象]
document.body.onclick=function(ev){
//默认传ev，ev=》事件对象：给元素的某个事件绑定方法，当事件触发会执行这个方法，并且会把当前事件的相关信息传递给这个函数的事件对象
```


```js
let obj={
    name:'OBJ'
}

function fn(...arg){
    console.log(this,arg)
}
// 点击的时候，fn中this变成obj，arg为[1,2]

document.body.onclick=fn.bind(obj,1,2)
// 等同于：
document.body.onclick=function(ev){
    fn.call(obj,1,2,ev);
    fn.apply(obj,[1,2,ev]);
}
}
```
等同于
```js
(function(){
    function myBind(context=window,...outArg){
        //this:需要改变this的函数
        //context:改变this指向
        //outArg：其余传递给函数的实参信息
        let _this=this;
        return function(...inerArg){
            _this.call(context,...outArg.concat(innerArg));
        }   
    }
    Function.prototype.myBind=myBind;
})()
doucument.body.onclick=fn.myBind(obj,1000,2000);

```