# 编程输出题

```js
var name=1
var obj={
    name:2,
    getname:function(){
        return function(){
            return this.name
        }
    }
}
console.log(obj.getname()())//1

obj.getname()()
// 等同于
function(){
        return function(){
            return this.name
        }
    }()
```

```js
var name=1
var obj={
    name:2,
    getname:function(){
        // 缓存this
        var that=this;
        return function(){
            return that.name
        }
    }
}
console.log(obj.getname()())//2
```

```js
function fn(){
    return console.log(1)
}
console.log(fn())
//1 undefined
```

```js
function fn(n,o){
    console.log(o)
    return{
        fn:function(m){
            return fn(m,n)
        }
    }
}
var a=fn(0)//undefined
//这时 n=0，o=undefined
// a={
//     fn:function(m){
//         return fn(m,0)
//     }
// }

a.fn(1)
// 0
a.fn(2)
//0
a.fn(3)
//0


var b=fn(0).fn(1).fn(2).fn(3)
// undefined
// 0
// 1
// 2
```

```js
function Foo(){
    getName=function(){console.log(1)}
    return this
}
Foo.getName=function(){console.log(2)}
Foo.prototype.getName=function(){console.log(3)}
var getName=function(){console.log(4)}
function getName(){console.log(5)}

Foo.getName()//2
getName()//4
Foo().getName()//等同于 window.getName()  1
getName()//1
new Foo.getName() //2
new Foo().getName();//3 实例化的对象没有实例方法
new new Foo().getName();//3
```

```js
var n=123;
function f1(){
    console.log(n);
}

function f2(){
    var n=456;
    f1();//f1在f2执行，作用域 无调用者 f1作用域是window
}

f2();//123 无调用者，window
f1();//123 无调用者， window
console.log(n)
```

```js
var length=100;
function f1(){
    console.log(this.length)//this会变，数组长度属性lenght
}

var obj={
    x:10,
    f2:function(f1){
        console.log(this)//obj
        f1();//无调用者 this==window
        arguments[0]();//argument[0]=f1 无调用者 ， 作用域arguments对象；
    }
}
obj.f2(f1,1)

// arguments:内置函数，参数数组
```

```js
function f(){
    console.log(this.a);//this
}
var obj={
    a:2,
    f:f
}
var f2=obj.f;
var a='hello'
f2();//hello 无调用者 this==window
obj.f() //2 有调用者
```

```js
function f(s){
    console.log(this.a,s);
    return this.a+s;
}
obj={
    a:2
}

var f2=function(){//无形参接收， argument
    return f.apply(obj,arguments);
    // return f.call(obj,...arguments);
}

var b=f2(3);
console.log(b) 
//2,3
//5
```

```js
var a=10;
function test(){
    // var a;
    a=100;//提升变量，前面插一句var a;
    console.log(a);//100
    console.log(this.a);//10
    var a;
    console.log(a);//100
}
test(); //无调用者，this==》window
// 变量提升(var)
```

## 作用域
```js
(function(){
    // a 作用域： 函数作用域；
    var a=b=3
    //等同于
    // b=3;
    // var a=b;
})()
console.log(a,b)
// a is not defined 
// b =>3
```

## 自执行函数
自执行含糊，自动执行，无调用者，
```js
(function d(num){
    console.log(num);
    var num=10
}(100))
// 等同于
(function d(num){
    console.log(num);
    var num=10
})(100)
// 等价于
d(100)

//100
```

```js
for(var i=1;i<=3;i++){
    setTimeout(function(){
        console.log(i)
    },0)
}
```

```js
function fn(n){
    // n=undefined
    console.log(n);
    var n=456;
    console.log(n);
}
var n=123;
fn(n)
//123 456
//分析 n默认为undefined；

function fn(){
    //n变量提升
    console.log(n);
    var n=456;
    console.log(n);
}
var n=123;
fn(n)
//undefined 456

function fn(){
    //n变量提升
    console.log(n);//123 找不到n，出去外面找
    n=456;
    console.log(n);//456 修改了外面的n
}
var n=123;
fn(n)
console.log(n)//456

```

```js
var n=123;
function f1(){
    console.log(n)
}
function f2(){
    var n=456;
    f1();
}
f2();//123
console.log(n)//123
```

## var和fun
函数比var优先级更高！！！
```js
function b(){
    // a=fun
    console.log(a);//var a=undefined fun=fn 函数比var优先级更高！！！
    var a=10;
    function a(){}
    a=100;
    console.log(a)// fn 100
}
b();
```
### 自执行函数
```js
(function e(num){
    console.log(num);
    var num=10;
    function num(){}
})(100)
```

## 预解析 作用域
```js
function m(){
    console.log(a1) //undefined
    console.log(a2) //undefined
    console.log(b1) //undefined
    console.log(b2) //undefined
    if(false){
        // 代码块，只有执行的时候才会解析
        function b1(){}
        var a1=100
    }
    if(true){
        // 代码块，只有执行的时候才会解析
        function b2(){}
        var a2=10
    }
    console.log(a1)//undefined
    console.log(a2)//10
    console.log(b1)//undefined
    console.log(b2)//fn
}
m()
```

fun=fn 函数比var优先级更高！！！
```js
(function f(num){
    function num(){}// num=100 num=fn 变量提升
    console.log(num);//fn
    var num=10;
    console.log(num)//10
})(100)

// 等同于

(function f(num){
    console.log(num);//fn
    var num=10;
    function num(){}// num=100 num=fn 变量提升
    console.log(num)//10
})(100)

// 等同于

(function f(num){
    console.log(num);//fn
    var num=10;
    console.log(num)//10
    function num(){}// num=100 num=fn 变量提升
})(100)
```

## 预解析 声明变量
```js
function n(){
    if(2>1){
        arr=10;//报错。先定义，后使用
        brr=10;
        let arr;
        var brr;
        console.log(arr);
        console.log(brr);
    }
}
n();//报错

```
## 自执行 闭包
```js
var R=(function(){
    var u={a:1,b:2};
    var r={
        fn:function(k){
            return u[k];
        }
    }
    return r;
})();
R.fn('a')
//1
```

## 自执行 无调用者 自动执行
```js
(function(){
    console.log('自执行函数')
})()
```